// Copyright (c) Microsoft Corporation
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#include "pch.h"
#include "xsapi/title_storage_c.h"
#include "title_storage_taskargs.h"
#include "xbox_live_context_impl.h"
#include "title_storage_blob_metadata_impl.h"

using namespace xbox::services::title_storage;

HC_RESULT get_quota_execute(
    _In_opt_ void* context,
    _In_ HC_TASK_HANDLE taskHandle
    )
{
    auto args = reinterpret_cast<get_quota_taskargs*>(context);
    auto titleStorageService = args->pXboxLiveContext->pImpl->cppObject().title_storage_service();

    auto result = titleStorageService.get_quota(
        utils::to_utf16string(args->serviceConfigurationId),
        static_cast<title_storage_type>(args->storageType))
        .get();

    args->copy_xbox_live_result(result);

    args->completionRoutinePayload.serviceConfigurationId = args->serviceConfigurationId.data();
    args->completionRoutinePayload.storageType = args->storageType;

    if (!result.err())
    {
        XSAPI_TITLE_STORAGE_QUOTA& quota = args->completionRoutinePayload;

        args->xboxUserId = utils::to_utf8string(result.payload().xbox_user_id());
        quota.xboxUserId = args->xboxUserId.data();

        quota.usedBytes = result.payload().used_bytes();
        quota.quotaBytes = result.payload().quota_bytes();
    }

    return HCTaskSetCompleted(taskHandle);
}

XSAPI_DLLEXPORT XSAPI_RESULT XBL_CALLING_CONV
TitleStorageGetQuota(
    _In_ XSAPI_XBOX_LIVE_CONTEXT* pContext,
    _In_ PCSTR serviceConfigurationId,
    _In_ XSAPI_TITLE_STORAGE_TYPE storageType,
    _In_ XSAPI_GET_QUOTA_COMPLETION_ROUTINE completionRoutine,
    _In_opt_ void* completionRoutineContext,
    _In_ uint64_t taskGroupId
    ) XSAPI_NOEXCEPT
try
{
    verify_global_init();

    auto args = new get_quota_taskargs();
    args->pXboxLiveContext = pContext;
    args->serviceConfigurationId = serviceConfigurationId;
    args->storageType = storageType;

    return utils::xsapi_result_from_hc_result(
        HCTaskCreate(
            taskGroupId,
            get_quota_execute,
            static_cast<void*>(args),
            utils::execute_completion_routine_with_payload<get_quota_taskargs, XSAPI_GET_QUOTA_COMPLETION_ROUTINE>,
            static_cast<void*>(args),
            static_cast<void*>(completionRoutine),
            completionRoutineContext,
            nullptr
        ));
}
CATCH_RETURN()

HC_RESULT get_blob_metadata_execute(
    _In_opt_ void* context,
    _In_ HC_TASK_HANDLE taskHandle
    )
{
    auto args = reinterpret_cast<get_blob_metadata_taskargs*>(context);
    auto titleStorageService = args->pXboxLiveContext->pImpl->cppObject().title_storage_service();

    auto result = titleStorageService.get_blob_metadata(
        utils::to_utf16string(args->serviceConfigurationId),
        static_cast<title_storage_type>(args->storageType),
        utils::to_utf16string(args->blobPath),
        utils::to_utf16string(args->xboxUserId),
        args->skipItems,
        args->maxItems)
        .get();

    args->copy_xbox_live_result(result);

    if (!result.err())
    {
        auto& metadataResultImpl = get_xsapi_singleton()->m_titleStorageState->m_blobMetadataResultImpl;

        metadataResultImpl.update(result.payload());

        args->completionRoutinePayload.itemCount = metadataResultImpl.item_count();
        args->completionRoutinePayload.hasNext = metadataResultImpl.cppObject().has_next();
        args->completionRoutinePayload.items = metadataResultImpl.first_item();
    }
    return HCTaskSetCompleted(taskHandle);
}

XSAPI_DLLEXPORT XSAPI_RESULT XBL_CALLING_CONV
TitleStorageGetBlobMetadata(
    _In_ XSAPI_XBOX_LIVE_CONTEXT* pContext,
    _In_ PCSTR serviceConfigurationId,
    _In_ XSAPI_TITLE_STORAGE_TYPE storageType,
    _In_ PCSTR blobPath,
    _In_ PCSTR xboxUserId,
    _In_ uint32_t skipItems,
    _In_ uint32_t maxItems,
    _In_ XSAPI_GET_BLOB_METADATA_COMPLETION_ROUTINE completionRoutine,
    _In_opt_ void* completionRoutineContext,
    _In_ uint64_t taskGroupId
    ) XSAPI_NOEXCEPT
try
{
    verify_global_init();

    auto args = new get_blob_metadata_taskargs();
    args->pXboxLiveContext = pContext;
    args->serviceConfigurationId = serviceConfigurationId;
    args->storageType = storageType;
    args->skipItems = skipItems;
    args->maxItems = maxItems;

    if (blobPath != nullptr)
    {
        args->blobPath = blobPath;
    }

    if (xboxUserId != nullptr)
    {
        args->xboxUserId = xboxUserId;
    }

    return utils::xsapi_result_from_hc_result(
        HCTaskCreate(
            taskGroupId,
            get_blob_metadata_execute,
            static_cast<void*>(args),
            utils::execute_completion_routine_with_payload<get_blob_metadata_taskargs, XSAPI_GET_BLOB_METADATA_COMPLETION_ROUTINE>,
            static_cast<void*>(args),
            static_cast<void*>(completionRoutine),
            completionRoutineContext,
            nullptr
        ));
}
CATCH_RETURN()

HC_RESULT blob_metadata_result_get_next_execute(
    _In_opt_ void* context,
    _In_ HC_TASK_HANDLE taskHandle
    )
{
    auto args = reinterpret_cast<blob_metadata_result_get_next_taskargs*>(context);

    auto& metadataResultImpl = get_xsapi_singleton()->m_titleStorageState->m_blobMetadataResultImpl;
    auto result = metadataResultImpl.cppObject().get_next(args->maxItems).get();

    args->copy_xbox_live_result(result);

    if (!result.err())
    {
        metadataResultImpl.update(result.payload());

        args->completionRoutinePayload.itemCount = metadataResultImpl.item_count();
        args->completionRoutinePayload.hasNext = metadataResultImpl.cppObject().has_next();
        args->completionRoutinePayload.items = metadataResultImpl.first_item();
    }
    return HCTaskSetCompleted(taskHandle);
}

XSAPI_DLLEXPORT XSAPI_RESULT XBL_CALLING_CONV
TitleStorageBlobMetadataResultGetNext(
    _In_ XSAPI_TITLE_STORAGE_BLOB_METADATA_RESULT metadataResult,
    _In_ uint32_t maxItems,
    _In_ XSAPI_GET_BLOB_METADATA_COMPLETION_ROUTINE completionRoutine,
    _In_opt_ void* completionRoutineContext,
    _In_ uint64_t taskGroupId
    ) XSAPI_NOEXCEPT
try
{
    verify_global_init();

    auto singleton = get_xsapi_singleton();
    {
        std::lock_guard<std::recursive_mutex> lock(singleton->m_titleStorageState->m_lock);
        if (!singleton->m_titleStorageState->m_blobMetadataResultImpl.cppObject().has_next())
        {
            return XSAPI_RESULT_E_GENERIC_ERROR;
        }
    }
    auto args = new blob_metadata_result_get_next_taskargs();
    args->maxItems = maxItems;

    return utils::xsapi_result_from_hc_result(
        HCTaskCreate(
            taskGroupId,
            blob_metadata_result_get_next_execute,
            static_cast<void*>(args),
            utils::execute_completion_routine_with_payload<blob_metadata_result_get_next_taskargs, XSAPI_GET_BLOB_METADATA_COMPLETION_ROUTINE>,
            static_cast<void*>(args),
            static_cast<void*>(completionRoutine),
            completionRoutineContext,
            nullptr
        ));
}
CATCH_RETURN()

XSAPI_DLLEXPORT XSAPI_RESULT XBL_CALLING_CONV
TitleStorageCreateBlobMetadata(
    _In_ PCSTR serviceConfigurationId,
    _In_ XSAPI_TITLE_STORAGE_TYPE storageType,
    _In_ PCSTR blobPath,
    _In_ XSAPI_TITLE_STORAGE_BLOB_TYPE blobType,
    _In_opt_ PCSTR xboxUserId,
    _In_opt_ PCSTR displayName,
    _In_opt_ PCSTR etag,
    _In_opt_ time_t* pClientTimeStamp,
    _Out_ CONST XSAPI_TITLE_STORAGE_BLOB_METADATA** ppMetadata
    ) XSAPI_NOEXCEPT
try
{
    auto singleton = get_xsapi_singleton();
    std::lock_guard<std::recursive_mutex> lock(singleton->m_titleStorageState->m_lock);

    auto pMetadata = new XSAPI_TITLE_STORAGE_BLOB_METADATA();

    title_storage_blob_metadata cppMetadata = title_storage_blob_metadata(
        utils::to_utf16string(serviceConfigurationId),
        static_cast<title_storage_type>(storageType),
        utils::to_utf16string(blobPath),
        static_cast<title_storage_blob_type>(blobType),
        xboxUserId == nullptr ? string_t() : utils::to_utf16string(xboxUserId),
        displayName == nullptr ? string_t() : utils::to_utf16string(displayName),
        etag == nullptr ? string_t() : utils::to_utf16string(etag),
        utility::datetime() /* TODO */);

    pMetadata->pImpl = new XSAPI_TITLE_STORAGE_BLOB_METADATA_IMPL(pMetadata, cppMetadata);
    singleton->m_titleStorageState->m_blobMetadata.insert(pMetadata);

    *ppMetadata = pMetadata;

    return XSAPI_RESULT_OK;
}
CATCH_RETURN()

XSAPI_DLLEXPORT XSAPI_RESULT XBL_CALLING_CONV
TitleStorageReleaseBlobMetadata(
    _In_ CONST XSAPI_TITLE_STORAGE_BLOB_METADATA* pMetadata
    ) XSAPI_NOEXCEPT
try
{
    auto singleton = get_xsapi_singleton();
    std::lock_guard<std::recursive_mutex> lock(singleton->m_titleStorageState->m_lock);

    size_t erasedItems = singleton->m_titleStorageState->m_blobMetadata.erase(pMetadata);
    if (erasedItems > 0 && pMetadata->pImpl != nullptr)
    {
        delete pMetadata->pImpl;
    }
    return XSAPI_RESULT_OK;
}
CATCH_RETURN()

HC_RESULT delete_blob_execute(
    _In_opt_ void* context,
    _In_ HC_TASK_HANDLE taskHandle
    )
{
    auto args = reinterpret_cast<delete_blob_taskargs*>(context);
    auto titleStorageService = args->pXboxLiveContext->pImpl->cppObject().title_storage_service();

    auto result = titleStorageService.delete_blob(args->pMetadata->pImpl->cppObject(), args->deleteOnlyIfEtagMatches).get();

    args->copy_xbox_live_result(result);

    return HCTaskSetCompleted(taskHandle);
}

XSAPI_DLLEXPORT XSAPI_RESULT XBL_CALLING_CONV
TitleStorageDeleteBlob(
    _In_ XSAPI_XBOX_LIVE_CONTEXT* pContext,
    _In_ CONST XSAPI_TITLE_STORAGE_BLOB_METADATA* pMetadata,
    _In_ bool deleteOnlyIfEtagMatches,
    _In_ XSAPI_DELETE_BLOB_COMPLETION_ROUTINE completionRoutine,
    _In_opt_ void* completionRoutineContext,
    _In_ uint64_t taskGroupId
    ) XSAPI_NOEXCEPT
try
{
    verify_global_init();

    if (pContext == nullptr || pMetadata == nullptr || pMetadata->pImpl == nullptr)
    {
        return XSAPI_RESULT_E_HC_INVALIDARG;
    }

    auto args = new delete_blob_taskargs();
    args->pXboxLiveContext = pContext;
    args->pMetadata = pMetadata;
    args->deleteOnlyIfEtagMatches = deleteOnlyIfEtagMatches;

    return utils::xsapi_result_from_hc_result(
        HCTaskCreate(
            taskGroupId,
            delete_blob_execute,
            static_cast<void*>(args),
            utils::execute_completion_routine<delete_blob_taskargs, XSAPI_DELETE_BLOB_COMPLETION_ROUTINE>,
            static_cast<void*>(args),
            static_cast<void*>(completionRoutine),
            completionRoutineContext,
            nullptr
        ));
}
CATCH_RETURN()

HC_RESULT download_blob_execute(
    _In_opt_ void* context,
    _In_ HC_TASK_HANDLE taskHandle
)
{
    auto args = reinterpret_cast<download_blob_taskargs*>(context);
    auto titleStorageService = args->pXboxLiveContext->pImpl->cppObject().title_storage_service();

    // TODO Is there a better way to do this
    auto blobBufferSharedPtr = std::make_shared<std::vector<unsigned char>>(args->cbBlobBuffer);

    auto result = titleStorageService.download_blob(
        args->pMetadata->pImpl->cppObject(),
        blobBufferSharedPtr,
        static_cast<title_storage_e_tag_match_condition>(args->etagMatchCondition),
        args->selectQuery == nullptr ? string_t() : utils::to_utf16string(args->selectQuery),
        args->preferredDownloadBlockSize == nullptr ? title_storage_service::DEFAULT_DOWNLOAD_BLOCK_SIZE : *(args->preferredDownloadBlockSize))
        .get();

    args->copy_xbox_live_result(result);

    if (!result.err())
    {
        args->pMetadata->pImpl->update(result.payload().blob_metadata());
        args->completionRoutinePayload.pMetadata = args->pMetadata;

        memcpy(args->blobBuffer, blobBufferSharedPtr->data(), args->cbBlobBuffer);
        args->completionRoutinePayload.blobBuffer = args->blobBuffer;

        args->completionRoutinePayload.cbBlobBuffer = blobBufferSharedPtr->size();
    }
    return HCTaskSetCompleted(taskHandle);
}

XSAPI_DLLEXPORT XSAPI_RESULT XBL_CALLING_CONV
TitleStorageDownloadBlob(
    _In_ XSAPI_XBOX_LIVE_CONTEXT* pContext,
    _In_ CONST XSAPI_TITLE_STORAGE_BLOB_METADATA* pMetadata,
    _In_ PBYTE blobBuffer,
    _In_ size_t cbBlobBuffer,
    _In_ XSAPI_TITLE_STORAGE_E_TAG_MATCH_CONDITION etagMatchCondition,
    _In_opt_ PCSTR selectQuery,
    _In_opt_ uint32_t* preferredDownloadBlockSize,
    _In_ XSAPI_DOWNLOAD_BLOB_COMPLETION_ROUTINE completionRoutine,
    _In_opt_ void* completionRoutineContext,
    _In_ uint64_t taskGroupId
    ) XSAPI_NOEXCEPT
try
{
    verify_global_init();

    if (pContext == nullptr || pMetadata == nullptr || pMetadata->pImpl == nullptr)
    {
        return XSAPI_RESULT_E_HC_INVALIDARG;
    }

    auto args = new download_blob_taskargs();
    args->pMetadata = pMetadata;
    args->pXboxLiveContext = pContext;
    args->blobBuffer = blobBuffer;
    args->cbBlobBuffer = cbBlobBuffer;
    args->etagMatchCondition = etagMatchCondition;
    args->selectQuery = selectQuery;
    args->preferredDownloadBlockSize = preferredDownloadBlockSize;

    return utils::xsapi_result_from_hc_result(
        HCTaskCreate(
            taskGroupId,
            download_blob_execute,
            static_cast<void*>(args),
            utils::execute_completion_routine_with_payload<download_blob_taskargs, XSAPI_DOWNLOAD_BLOB_COMPLETION_ROUTINE>,
            static_cast<void*>(args),
            static_cast<void*>(completionRoutine),
            completionRoutineContext,
            nullptr
        ));
}
CATCH_RETURN()

HC_RESULT upload_blob_execute(
    _In_opt_ void* context,
    _In_ HC_TASK_HANDLE taskHandle
)
{
    auto args = reinterpret_cast<upload_blob_taskargs*>(context);
    auto titleStorageService = args->pXboxLiveContext->pImpl->cppObject().title_storage_service();

    // TODO Is there a better way to do this
    auto blobBufferSharedPtr = std::make_shared<std::vector<unsigned char>>(args->blobBuffer, args->blobBuffer + args->cbBlobBuffer);

    auto result = titleStorageService.upload_blob(
        args->pMetadata->pImpl->cppObject(),
        blobBufferSharedPtr,
        static_cast<title_storage_e_tag_match_condition>(args->etagMatchCondition),
        args->preferredUploadBlockSize == nullptr ? title_storage_service::DEFAULT_UPLOAD_BLOCK_SIZE : *(args->preferredUploadBlockSize))
        .get();

    args->copy_xbox_live_result(result);

    if (!result.err())
    {
        args->pMetadata->pImpl->update(result.payload());
        args->completionRoutinePayload = args->pMetadata;
    }
    return HCTaskSetCompleted(taskHandle);
}

XSAPI_DLLEXPORT XSAPI_RESULT XBL_CALLING_CONV
TitleStorageUploadBlob(
    _In_ XSAPI_XBOX_LIVE_CONTEXT* pContext,
    _In_ CONST XSAPI_TITLE_STORAGE_BLOB_METADATA* pMetadata,
    _In_ PBYTE blobBuffer,
    _In_ size_t cbBlobBuffer,
    _In_ XSAPI_TITLE_STORAGE_E_TAG_MATCH_CONDITION etagMatchCondition,
    _In_opt_ uint32_t* preferredUploadBlockSize,
    _In_ XSAPI_UPLOAD_BLOB_COMPLETION_ROUTINE completionRoutine,
    _In_opt_ void* completionRoutineContext,
    _In_ uint64_t taskGroupId
    ) XSAPI_NOEXCEPT
try
{
    verify_global_init();

    if (pContext == nullptr || pMetadata == nullptr || pMetadata->pImpl == nullptr)
    {
        return XSAPI_RESULT_E_HC_INVALIDARG;
    }

    auto args = new upload_blob_taskargs();
    args->pMetadata = pMetadata;
    args->pXboxLiveContext = pContext;
    args->blobBuffer = blobBuffer;
    args->cbBlobBuffer = cbBlobBuffer;
    args->etagMatchCondition = etagMatchCondition;
    args->preferredUploadBlockSize = preferredUploadBlockSize;

    return utils::xsapi_result_from_hc_result(
        HCTaskCreate(
            taskGroupId,
            upload_blob_execute,
            static_cast<void*>(args),
            utils::execute_completion_routine_with_payload<upload_blob_taskargs, XSAPI_UPLOAD_BLOB_COMPLETION_ROUTINE>,
            static_cast<void*>(args),
            static_cast<void*>(completionRoutine),
            completionRoutineContext,
            nullptr
        ));
}
CATCH_RETURN()